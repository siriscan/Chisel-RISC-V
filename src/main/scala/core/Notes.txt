/* Making hex file:
  - First line is the starting address (e.g., 00000000), 
  which should match the startPC in CoreConfig.
  - Since FetchStage starts at nextPc = startPC, the first line should be
  NOP (0x00000013).
 */

// So far, I have implemented a basic 5-stage RISC-V pipeline with hazard detection and forwarding.
// It supports basic integer instructions including arithmetic, load/store, and branches.
// It has multiply/divide support in the Execute stage.

/* Todo: 
 - Add atomic instructions and pipeline support
 - Add single-precision floating point support
 - Add bfloat16 support
 - Add CSR instructions and pipeline support (Not needed for this project)
 - Add vector instructions and pipeline support
 - Add cache between Memory stage and Data Memory
 - Add branch prediction in Fetch stage
    - BTB, Dynamic Branch Preidctors, Return Address Stack
    - Delay Slots for Branches for now
    - BTB for jal and Return Address Stack for jalr
 - Optimize hazard detection and forwarding logic
 - Synthesize on FPGA and test with real hardware
 - Organize code into packages and modules for better maintainability

 * Note: For synthesis, remove the memory initialization from InstructionMem.scala
 * Also, make sure that the memory size and other parameters match FPGA constraints.
 */